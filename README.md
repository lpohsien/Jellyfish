# Overview

## Dependancies

Do note that to use all of these, the following packages are relevant:

- dji_sdk (must for HITL, and really, to run the actual drone)
- dji_sdk_demo (if you wna run dji's demo)
- rotors_simulator (must for SITL)
- video_stream_opencv (CV stuff)
- image_pipeline (CV stuff)

## Features
Currently this repository includes the following features: 

### HITL simulation

- Using this mode would allow the simulation of the drone more accurately, and access to a all of dji_sdk topics, features etc. BUT you need the drone   with you and a windows lappy with DJI assistant 2. The dji_sdk the jellyfish uses (version 3.8) is already included in this repository
- To use the dji_sdk ros package, a UserConfig.txt file (found in the root directory of this repo) needs to be in /home/{user}/.ros

### SITL simulation

- Based off the rotors_simulator package
- Drone is simulated with a gimbal.
- Included a urdf model of the dji m100 (due to lack of a mesh for the dji m210). Model can be edited for different drones
- Simulation of individual thrusts being generated by the drone's propeller. Controllers can be written and simulated using this feature. Currently       using basic position controller for controls in this simulation
- Basic position controller (Off which the current dji_sdk mimicing node is based off on)

### A fake dji_sdk node

Mimics some basic functionalities of dji's sdk. It should be noted that the movement controls does not have the drone moving very cleanly (jerky movements over longer distances etc). However, it should be sufficient for testing of drone's logic (missions, behaviour tree etc). Mimiced features include:

- GPS position
- IMU
- Control Authority requesting
- Take off drone task
- Movement based off on the dji_sdk/flight_control_setpoint_ENUposition_yaw

### Very basic movement control code 

- Moves the drone to a desired GPS coordinate. 
- This uses dji_sdk/flight_control_setpoint_ENUposition_yaw to move, and can runs in both the HITL simulation (using dji's simulator) and the SITL simulation

### Some aruco tag stuff 

- Stuff im working on for DTLS

# Usage

To run a demonstration of this package, clone this repository into your workspace and build. After that, run the SITL simulation without the basic drone controller using the following command

`
roslaunch jellyfish_sim simulate.launch use_basic_controller:=false
`

In another terminal,run the following command to command the props to spin and generate thrust. Increasing the thrust values would cause the drone to start ascending

`
rostopic pub /dji_m210/command/motor_speed mav_msgs/Actuators '{angular_velocities: [100, 100, 100, 100]}'
`

## SITL

To run a demonstration of movement control using the fake_dji_sdk, run the following 

`
roslaunch jellyfish_sim simulate.launch
`

In a seperate terminal, run

`
roslaunch jellyfish_sim fake_dji_sdk.launch
`

Then, use the demo drone_movement_control node to command the drone to take off

`
rosrun jellyfish drone_movement_control.py  
`

The same node you just launched includes a service that moves the drone to a desired gps coordinate. The drone is spawned at gps coordinates 0,0,50. To try this, run the following. Take note that yaw movement is not implemented yet (whoooops)

`
rosservice call /set_goalpoint "latitude: 0.0
longitude: 0.0001
altitude: 57.0
yaw: 0.0"
`

Alternatively, control via dji_sdk/flight_control_setpoint_ENUposition_yaw can be tested using the following command

`
rostopic pub /dji_sdk/flight_control_setpoint_ENUposition_yaw sensor_msgs/Joy "{header: {seq: 0, stamp: {secs: 0, nsecs: 0}, frame_id: ''}, axes: [1.0, 1.0, 54, 0.0], buttons:[]}"
`

## HITL

To run a demonstration of movement control using the the actual dji_sdk and the bonkers amount of hardware required to do so, run the following 

`
roslaunch dji_sdk sdk.launch
`

Next, start the simulation in DJI assistant 2. The HITL sim bridge uses the local position of the drone and mimics it in gazebo. Hence, call the following service

`
rosservice call /dji_sdk/set_local_pos_ref
`

In a seperate terminal, run

`
roslaunch jellyfish_sim simulate.launch is_SITL:=false
`

Then, use the demo drone_movement_control node to command the drone to take off

`
rosrun jellyfish drone_movement_control.py  
`

The same node you just launched includes a service that moves the drone to a desired gps coordinate. Make sure that the GPS cooridnates you command it to move to is not thousands of kilometers away by ensuring that the commanded coordinates are not thousands of kilometer away from the start point. The initial GPS coordinates can be configured in dji assistant. Take note that yaw movement is not implemented yet (whoooops)

`
rosservice call /set_goalpoint "latitude: Your lattitude
longitude: Your longitude
altitude: Your Altitude
yaw: 0.0"
`

Alternatively, control via dji_sdk/flight_control_setpoint_ENUposition_yaw can be tested using the following command. Do note that the altitude input needs to be higher than the spawn altitude (Configurable in dji assistant).

`
rostopic pub /dji_sdk/flight_control_setpoint_ENUposition_yaw sensor_msgs/Joy "{header: {seq: 0, stamp: {secs: 0, nsecs: 0}, frame_id: ''}, axes: [1.0, 1.0, your desired altitude, 0.0], buttons:[]}"
`
